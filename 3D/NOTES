
My targetting code doesn't work with Momentary Blink, since it doesn't see the card as a different permanent from the one that left - the change is to save the permenant object and compare them in check_target.

See here: http://www.pojo.com/magic/featured%20writers/Judge/z_ask_here.shtml

DEBT is an acronym. It stands for Damage, Enchantments/Equipment, Blocking, and Targeting, which are the 5 things a creature with protection is protected from.

    For an extended definition, protection is usually written on a card as "Protection from [quality]." (For example, "Protection from green.")

    -Damage: All damage dealt to the permanent from a source with the stated quality is prevented.

    -Enchantments: The permanent can't be enchanted by permanents with the stated quality.

    -Equipment: The permanent can't be equipped by Equipment with the stated quality. Such an Equipment stops equipping that permanent, but remains in play.

    -Blocking: The permanent can't be blocked by permanents with the stated quality.

    -Targeting: The permanent can't be targeted by spells with the stated quality, or abilities from permanents with the stated quality. (Remember Mantra #3.) 

* There are two in play zones (one per player, although in the game there is only one)
this means that both zones will have to checked by continuous effects

Ability.played is called when an ability is played (either placed on the stack or automatically if not going to the stack). However, it only seems to be used by the Cycling Ability to trigger and Cycling triggers. There has to be a better way - possibly with a CyclingEvent. Does any other card need to know when it is being played?

- Oh, I figured out the reason. It is used for Instants or Sorceries (such as Choking Tethers) which have no triggered abilities. I'm also having this problem with Prowl and other keyword abilities. Maybe NonPermanents should also be able to trigger events when they are played.


Some information about the game structure
----------------------------------------------------
The implementation of the game inverts  normal gui paradigm. The central GameKeeper program runs through all the phases in order until the game ends. Basically the game is run by the GameKeeper, which iterates through all the steps. Whenever input is needed from the player, the appropriate function in Player is called, which calls a function which returns control to the gui loop (through a fake coroutine added to the player) along with context information to determine what to do with the actions generated by the player (through the gui). 
