
My targetting code doesn't work with Momentary Blink, since it doesn't see the card as a different permanent from the one that left - the change is to save the permenant object and compare them in check_target.

See here: http://www.pojo.com/magic/featured%20writers/Judge/z_ask_here.shtml

DEBT is an acronym. It stands for Damage, Enchantments/Equipment, Blocking, and Targeting, which are the 5 things a creature with protection is protected from.

    For an extended definition, protection is usually written on a card as "Protection from [quality]." (For example, "Protection from green.")

    -Damage: All damage dealt to the permanent from a source with the stated quality is prevented.

    -Enchantments: The permanent can't be enchanted by permanents with the stated quality.

    -Equipment: The permanent can't be equipped by Equipment with the stated quality. Such an Equipment stops equipping that permanent, but remains in play.

    -Blocking: The permanent can't be blocked by permanents with the stated quality.

    -Targeting: The permanent can't be targeted by spells with the stated quality, or abilities from permanents with the stated quality. (Remember Mantra #3.) 


Things that are hacky -

* The way the game is ended - currently a GameOver exception is raised
only SBE's should end the game, but in a better way

* There are two in play zones (one per player, although in the game there is only one)
this means that both zones will have to checked by continuous effects


Things to do:

* Characteristics are currently strings (or simple python objects), they need a special object that allows for a union of characteristics (or a characteristic object which can apply the continuous effect rules (Rule 418.5

* should there be a separate destroy function for the player?

Some information about the game structure
----------------------------------------------------
The implementation of the game inverts  normal gui paradigm. The central GameKeeper program runs through all the phases in order until the game ends. Basically the game is run by the GameKeeper, which iterates through all the steps. Whenever input is needed from the player, the appropriate function in Player is called, which calls a function which returns control to the gui loop (through a fake coroutine added to the player) along with context information to determine what to do with the actions generated by the player (through the gui). 
